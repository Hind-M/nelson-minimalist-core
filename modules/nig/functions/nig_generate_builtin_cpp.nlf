//=============================================================================
// Copyright (c) 2016-2017 Allan CORNET (Nelson)
//=============================================================================
// LICENCE_BLOCK_BEGIN
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
// LICENCE_BLOCK_END
//=============================================================================
function txt = nig_generate_builtin_cpp(NIG_FUNCTION)
  txt = nig_header_license();
  txt{end + 1} = ['// Generated by Nelson Interface Generator ', nig_version()];
  txt{end + 1} = '//=============================================================================';
  CppBuiltinName = [NIG_FUNCTION.NELSON_NAME, 'Builtin'];
  filenameHeaderBuiltin = [CppBuiltinName, '.hpp'];
  txt{end + 1} = '#include "Error.hpp"';
  txt{end + 1} = ['#include "', filenameHeaderBuiltin, '"'];
  txt{end + 1} = '//=============================================================================';
  txt{end + 1} = 'using namespace Nelson;';
  txt{end + 1} = '//=============================================================================';
  txt{end + 1} = '#ifdef __cplusplus';
  txt{end + 1} = 'extern "C"';
  txt{end + 1} = '{';
  txt{end + 1} = '#endif';
  txt{end + 1} = ['extern ', nig_language_function_declaration(NIG_FUNCTION), ';'];
  txt{end + 1} = '#ifdef __cplusplus';
  txt{end + 1} = '}';
  txt{end + 1} = '#endif';
  txt{end + 1} = '//=============================================================================';
  if isfield(NIG_FUNCTION, 'NELSON_NAMESPACE')
    txt{end + 1} = ['ArrayOfVector Nelson::', NIG_FUNCTION.NELSON_NAMESPACE, 'Gateway::', NIG_FUNCTION.NELSON_NAME, 'Builtin(Evaluator* eval, int nLhs, const ArrayOfVector& argIn)'];
  else
    txt{end + 1} = ['ArrayOfVector Nelson::', NIG_FUNCTION.NELSON_NAME, 'Builtin(Evaluator* eval, int nLhs, const ArrayOfVector& argIn)'];
  end
  txt{end + 1} = '{';
  txt{end + 1} = '    ArrayOfVector retval;';
  txt{end + 1} = ['    if (nLhs > ', int2str(nig_nargout(NIG_FUNCTION)) ,')'];
  txt{end + 1} = '    {';
  txt{end + 1} = '        Error(eval, ERROR_WRONG_NUMBERS_OUTPUT_ARGS);';
  txt{end + 1} = '    }';
  txt{end + 1} = ['    if (argIn.size() != ', int2str(nig_nargin(NIG_FUNCTION)), ')'];
  txt{end + 1} = '    {';
  txt{end + 1} = '        Error(eval, ERROR_WRONG_NUMBERS_INPUT_ARGS);';
  txt{end + 1} = '    }';
  txt{end + 1} = '';
  txt{end + 1} = '    // INPUT VARIABLES';
  n = 0;
  for k = NIG_FUNCTION.VARIABLES
    if strcmp(k.MODE, 'input') | strcmp(k.MODE, 'in_out')
      txt{end + 1} = ['    ArrayOf ', k.NAME, ' = argIn[', int2str(n), '];'];
      if strcmp(k.TYPE, 'double_array')
        txt{end + 1} = ['    ', k.NAME, '.promoteType(', 'NLS_DOUBLE', ');'];
        txt{end + 1} = ['    double *',  k.NAME, '_ptr = ', k.NAME, '.getDataPointer();'];
      end
     if strcmp(k.TYPE, 'integer_array')
        txt{end + 1} = ['    ', k.NAME, '.promoteType(', 'NLS_INT32', ');'];
        txt{end + 1} = ['    int *',  k.NAME, '_ptr = ', k.NAME, '.getDataPointer();'];
     end
     if strcmp(k.TYPE, 'character')
        txt{end + 1} = ['    std::string ',  k.NAME, '_string', ' = ', k.NAME, '.getContentAsCString();'];
        txt{end + 1} = ['    const char* ',  k.NAME, '_char', ' = ', k.NAME, '_string.c_str();'];
     end
      if strcmp(k.TYPE, 'double')
        txt{end + 1} = ['    double ',  k.NAME, '_scalar = ', k.NAME, '.getContentAsDoubleScalar();'];
      end
      if strcmp(k.TYPE, 'integer')
        txt{end + 1} = ['    int ',  k.NAME, '_scalar = ', k.NAME, '.getContentAsInteger32Scalar();'];
      end

      n = n + 1;
    end
  end
  txt{end + 1} = '';
  txt{end + 1} = '    // LOCAL VARIABLES';
  for k = NIG_FUNCTION.VARIABLES
    if strcmp(k.MODE, 'local')
      if strcmp(k.TYPE, 'double_array')
        if isfield(k, 'DIMENSION_M') & ~isempty(k.DIMENSION_M)
          if isnumeric(k.DIMENSION_M)
            DIMENSION_M_str = int2str(k.DIMENSION_M);
          else
            DIMENSION_M_str = k.DIMENSION_M;
          end
        else
          DIMENSION_M_str = '1';
        end
        if isfield(k, 'DIMENSION_N') & ~isempty(k.DIMENSION_N)
          if isnumeric(k.DIMENSION_N)
            DIMENSION_N_str = int2str(k.DIMENSION_N);
          else
            DIMENSION_N_str = k.DIMENSION_N;
          end
        else
          DIMENSION_N_str = '1';
        end
        txt{end + 1} = ['    double *', k.NAME, '_local = (double*)ArrayOf::allocateArrayOf(NLS_DOUBLE, ', DIMENSION_M_str, ' * ', DIMENSION_N_str ,';'];
      end
      if strcmp(k.TYPE, 'integer_array')
        if isfield(k, 'DIMENSION_M') & ~isempty(k.DIMENSION_M)
          if isnumeric(k.DIMENSION_M)
            DIMENSION_M_str = int2str(k.DIMENSION_M);
          else
            DIMENSION_M_str = k.DIMENSION_M;
          end
        else
          DIMENSION_M_str = '1';
        end
        if isfield(k, 'DIMENSION_N') & ~isempty(k.DIMENSION_N)
          if isnumeric(k.DIMENSION_N)
            DIMENSION_N_str = int2str(k.DIMENSION_N);
          else
            DIMENSION_N_str = k.DIMENSION_N;
          end
        else
          DIMENSION_N_str = '1';
        end
        txt{end + 1} = ['    int *', k.NAME, '_local = (int*)ArrayOf::allocateArrayOf(NLS_INT32, ', DIMENSION_M_str, ' * ', DIMENSION_N_str ,';'];
      end
      if strcmp(k.TYPE, 'double')
        if isfield(k, 'VALUE') & ~isempty(k.VALUE)
          txt{end + 1} = ['    double ', k.NAME, '_local = ', k.VALUE, ';'];
        else
          txt{end + 1} = ['    double ', k.NAME, '_local;'];
        end
      end
      if strcmp(k.TYPE, 'integer')
        if isfield(k, 'VALUE') & ~isempty(k.VALUE)
          txt{end + 1} = ['    int ', k.NAME, '_local = ', k.VALUE, ';'];
        else
          txt{end + 1} = ['    int ', k.NAME, '_local;'];
        end
      end

    end
  end


  txt{end + 1} = '';
  txt{end + 1} = '    // OUTPUT VARIABLES';
  for k = NIG_FUNCTION.VARIABLES
    if strcmp(k.MODE, 'output') | strcmp(k.MODE, 'in_out')
      if strcmp(k.MODE, 'in_out')
         txt{end + 1} = ['    ArrayOf ', k.NAME, '_output = ', k.NAME, ';'];
         txt{end + 1} = ['    ', k.NAME, '_output.ensureSingleOwner();'];
      else
       txt{end + 1} = ['    ArrayOf ', k.NAME, '_output;'];
      end
    end
  end
  txt{end + 1} = '';
  n = 0;
  for k = NIG_FUNCTION.VARIABLES
    if strcmp(k.MODE, 'output') | strcmp(k.MODE, 'in_out')
      txt{end + 1} = ['    if (nLhs > ', int2str(n), ')'];
      txt{end + 1} = '    {';
      
      if strcmp(k.TYPE, 'double_array')
          if isfield(k, 'DIMENSION_M') & ~isempty(k.DIMENSION_M)
          if isnumeric(k.DIMENSION_M)
            DIMENSION_M_str = int2str(k.DIMENSION_M);
          else
            DIMENSION_M_str = k.DIMENSION_M;
          end
        else
          DIMENSION_M_str = '1';
        end
        if isfield(k, 'DIMENSION_N') & ~isempty(k.DIMENSION_N)
          if isnumeric(k.DIMENSION_N)
            DIMENSION_N_str = int2str(k.DIMENSION_N);
          else
            DIMENSION_N_str = k.DIMENSION_N;
          end
        else
          DIMENSION_N_str = '1';
        end
        txt{end + 1} = ['        Dimensions dims(', DIMENSION_M_str, ' , ', DIMENSION_M_str, ');'];
        txt{end + 1} = ['        ', k.NAME, '_output = ArrayOf(NLS_DOUBLE, dims, ', k.NAME, '_ptr);'];
      end

      if strcmp(k.TYPE, 'integer_array')
          if isfield(k, 'DIMENSION_M') & ~isempty(k.DIMENSION_M)
          if isnumeric(k.DIMENSION_M)
            DIMENSION_M_str = int2str(k.DIMENSION_M);
          else
            DIMENSION_M_str = k.DIMENSION_M;
          end
        else
          DIMENSION_M_str = '1';
        end
        if isfield(k, 'DIMENSION_N') & ~isempty(k.DIMENSION_N)
          if isnumeric(k.DIMENSION_N)
            DIMENSION_N_str = int2str(k.DIMENSION_N);
          else
            DIMENSION_N_str = k.DIMENSION_N;
          end
        else
          DIMENSION_N_str = '1';
        end
        txt{end + 1} = ['        Dimensions dims(', DIMENSION_M_str, ' , ', DIMENSION_M_str, ');'];
        txt{end + 1} = ['        ', k.NAME, '_output = ArrayOf(NLS_INT32, dims, ', k.NAME, '_ptr);'];
      end

      if strcmp(k.TYPE, 'double')
        txt{end + 1} = ['        ', k.NAME, '_output = ArrayOf::doubleConstructor(', k.NAME, '_scalar);'];
      end

      if strcmp(k.TYPE, 'integer')
        txt{end + 1} = ['        ', k.NAME, '_output = ArrayOf::int32Constructor(', k.NAME, '_scalar);'];
      end

      txt{end + 1} = ['        retval.pushback(', k.NAME, '_output);'];
      txt{end + 1} = '    }';
      n = n + 1;
    end
  end


  txt{end + 1} = '    return retval;';
  txt{end + 1} = '}';
  txt{end + 1} = '//=============================================================================';

endfunction
//=============================================================================
